<!DOCTYPE html><html><head>	<meta charset="utf-8">	<title>My first three.js app</title>	<style>		body {			margin: 0;		}	</style></head><body>	<script src="js/three.js"></script>	<script src="js/OrbitControls.js"></script>	<script src="js/physi.js"></script>	<script src="js/GLTFLoader.js"></script>	<script src="js/perlin_noise.js"></script>	<script src="js/ammo.js"></script>	<script src="js/THREEBSP.js"></script>	<script>		Physijs.scripts.worker = 'js/physijs_worker.js';		//THREE types of material : MeshBasicMaterial,MeshPhongMaterial,MeshLambertMaterial.The second two require a light source.		//set variables for our entirer game		let scene, camera, friction, damping, renderer, spotLight, ambiLight, scoreText, infoText, timer, moon, ballObject, cubeMat, canvas, graphics;		//group for our orbiting planets		let group = new THREE.Group();		//next 5 lines is what we need for our rocket model to convert to physics		let rocketBuffer = new THREE.BufferGeometry();		let rocketThings = [];		let rocketMeshes = [];		let rocketObject, rocketObject2;		let r = new THREE.Geometry();		//next 5 lines is what we need for our astronaut model to convert to physics		let astronautBuffer = new THREE.BufferGeometry();		let astronautThings = [];		let astronautMeshes = [];		let astronautObject;		let a = new THREE.Geometry();		//Counts to keep track of the life of the objects		let rocketOneCount = 0,			rocketTwoCount = 0,			box1 = 0,			box2 = 0,			box3 = 0,			box4 = 0;		var mesh1, mesh2, mesh3, mesh4;		//list of our models		const models = {			moon: {				url: 'models/neptune/scene.gltf'			},			rocket: {				url: 'models/rocket/scene.gltf'			},		};		//object array to store all bullets that are currently alive		let bullets = [];		//object array to hold our models in a structure for easy accessing		let objects = [];		//array of enemies		let Enemies = [];		//loading manager which is important for models		const manager = new THREE.LoadingManager();		//calls the init function when we done loading model/s		manager.onLoad = init;		//loads our models by looping through object models ( a few lines up)		const gltfLoader = new THREE.GLTFLoader(manager);		for (const model of Object.values(models)) {			gltfLoader.load(model.url, (gltf) => {				objects.push(gltf.scene);			});		}		//setup function		function init() {			console.log(objects.length);			//gets the first model from objects array and makes it moon			moon = objects[0];			//transformations to moon			moon.position.y = 170;			moon.position.x = 250;			moon.position.z = 450;			moon.scale.set(15, 15, 15);			//adds to the group not the scene as we'll add the entire group to the scene at the end			group.add(moon);			//adds the score to the document			scoreText = document.createElement('div');			scoreText.style.position = 'absolute';			scoreText.style.width = 100;			scoreText.style.height = 100;			scoreText.style.color = "white";			scoreText.innerHTML = "0";			scoreText.style.top = 80 + 'px';			scoreText.style.left = 100 + 'px';			document.body.appendChild(scoreText);			//creates a canvas element that represents our map			canvas = document.createElement("CANVAS");			graphics = canvas.getContext("2d");			canvas.style.position = "absolute";			canvas.style.background = "white";			canvas.style.border = "4px solid white";			canvas.width = 900;			canvas.height = 900;			canvas.style.top = 480 + 'px';			canvas.style.left = 100 + 'px';			document.body.appendChild(canvas);			//adds info text to the document			infoText = document.createElement('div');			infoText.style.position = 'absolute';			infoText.style.width = 100;			infoText.style.height = 100;			infoText.style.color = "white";			infoText.innerHTML = "Use arrow keys to move and space bar to stop UFO. ESC to change view.Click on screen to shoot.Enter to jump";			infoText.style.top = 60 + 'px';			infoText.style.left = 100 + 'px';			document.body.appendChild(infoText);			//adds timer to the document			timer = document.createElement('div');			timer.style.position = 'absolute';			timer.style.width = 100;			timer.style.height = 100;			timer.style.color = 'white';			timer.innerHTML = "0";			timer.style.top = 33 + 'px';			timer.style.left = 100 + 'px';			document.body.appendChild(timer);			//Alert the user that the round is about to start and initialise scene/damping/friction			alert("Round 3 , Its A Massacre. Aim for a decent score in 75 seconds")			damping = 0;			friction = 0; //high			scene = new Physijs.Scene; //Scene physics			scene.setGravity(new THREE.Vector3(0, -20, 0)); //gravity for scene			//loads the sky material			var loader = new THREE.TextureLoader();			var mat = loader.load('textures/sky.jpg');			//creates massive cube which acts as a background(skybox)			cubeMat = new THREE.MeshBasicMaterial({				map: mat,				side: THREE.DoubleSide			});			var cube = new THREE.Mesh(new THREE.BoxGeometry(1700, 1700, 1700), cubeMat);			scene.add(cube);			//creates camera and positions it			camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);			camera.rotation.y = -Math.PI / 2;			camera.position.x = -120;			camera.position.y = 50;			//what must the camera look at			camera.lookAt(scene.position);			//renderer that renders our actual screen			renderer = new THREE.WebGLRenderer({				antialias: true			});			renderer.setSize(window.innerWidth, window.innerHeight);			document.body.appendChild(renderer.domElement);			//resize screen based on window size			window.addEventListener('resize', () => {				renderer.setSize(window.innerWidth, window.innerHeight);				camera.aspect = window.innerWidth / window.innerHeight;				camera.updateProjectionMatrix();			});			//second parameter of lights is the intensity, first is the color			//creates SpotLight for wall infront of car			var spotLight = new THREE.DirectionalLight(0xffffff, 0.5);			spotLight.position.set(-420, 20, 0); //spotLight doesnt need target			scene.add(spotLight);			//creates SpotLight for wall infront of car			var spotLight = new THREE.DirectionalLight(0xffffff, 0.5);			spotLight.position.set(420, 20, 0); //spotLight doesnt need target			scene.add(spotLight);			//creates SpotLight for wall infront of car			var spotLight = new THREE.DirectionalLight(0xffffff, 0.5);			spotLight.position.set(0, 20, -420); //spotLight doesnt need target			scene.add(spotLight);			var spotLight = new THREE.DirectionalLight(0xffffff, 0.5);			spotLight.position.set(0, 20, 420); //spotLight doesnt need target			scene.add(spotLight);			//creates DirectionalLight for the blue moon on top of the car, press ESC to see moon			var directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);			scene.add(directionalLight.target); //directionalLight must have a target			directionalLight.position.set(270, 170, 50);			directionalLight.target = moon; //respective target for directionalLight			scene.add(directionalLight);			//note that some walls are dim because no light shining on it			//adds general light to screen			var ambiLight = new THREE.AmbientLight(0xffffff, 1); //if set to 1 then no other light is needed but then we cant have shadows			//scene.add(ambiLight);			requestAnimationFrame(animate);		}		//function to create all the boxes in the scene which represent enemies		function boxes() {			//create general box			var cube = new THREE.CubeGeometry(45, 45, 45);			//texture laoder for all our textures			var loader = new THREE.TextureLoader();			var mat = loader.load('textures/color1.jpg');			var color1 = new THREE.MeshLambertMaterial({				map: mat			}); //sets box 1 to this texture			var mat2 = loader.load('textures/color2.jpg');			var color2 = new THREE.MeshLambertMaterial({				map: mat2			});			var mat3 = loader.load('textures/color3.jpg');			var color3 = new THREE.MeshLambertMaterial({				map: mat3			});			var mat4 = loader.load('textures/color4.jpg');			var color4 = new THREE.MeshLambertMaterial({				map: mat4			});			//creates physics objects of the above boxes			mesh1 = new Physijs.BoxMesh(cube, color1);			mesh2 = new Physijs.BoxMesh(cube, color2);			mesh3 = new Physijs.BoxMesh(cube, color3);			mesh4 = new Physijs.BoxMesh(cube, color4);			//positions box1			mesh1.position.x = 0;			mesh1.position.z = -240;			mesh1.position.y = 30;			//positions box2			mesh2.position.x = 360;			mesh2.position.z = 180;			mesh2.position.y = 30;			//positions box3			mesh3.position.x = 0;			mesh3.position.z = 360;			mesh3.position.y = 30;			//positions box4			mesh4.position.x = -300;			mesh4.position.z = -100;			mesh4.position.y = 30;			//sets the velocities to zero to prevent movement of these enemies			mesh1.setLinearVelocity(new THREE.Vector3(0, 0, 0));			mesh1.setAngularVelocity(new THREE.Vector3(0, 0, 0));			mesh2.setLinearVelocity(new THREE.Vector3(0, 0, 0));			mesh2.setAngularVelocity(new THREE.Vector3(0, 0, 0));			mesh3.setLinearVelocity(new THREE.Vector3(0, 0, 0));			mesh3.setAngularVelocity(new THREE.Vector3(0, 0, 0));			mesh4.setLinearVelocity(new THREE.Vector3(0, 0, 0));			mesh4.setAngularVelocity(new THREE.Vector3(0, 0, 0));			//adds enemies to enemies array for later use			Enemies.push(mesh1);			Enemies.push(mesh2);			Enemies.push(mesh3);			Enemies.push(mesh4);			mesh1.addEventListener("collision", function(object) {				x = object.id;				name = object.name;				//prevents rocket from moving when collided with				mesh1.setAngularVelocity(new THREE.Vector3(0, 0, 0));				mesh1.setLinearVelocity(new THREE.Vector3(0, 0, 0));				//checks if the collided object is the ufo and scale is a certain size				if (x == ufo.id) {					//resets car as its not big enough to destroy enemy					console.log("nope");					mesh1.setAngularVelocity(new THREE.Vector3(0, 0, 0));					mesh1.setLinearVelocity(new THREE.Vector3(0, 0, 0));					ufo.position.x = 0;					ufo.position.y = 20;					ufo.position.z = 0;					ufo.scale.set(2, 2, 2);					ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));					ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));					ufo.__dirtyPosition = true;					//sets score to 0					score = 0;					scoreText.innerHTML = score.toString();					clock.stop();					alert("You have failed this planet");					scene.add(rocketObject);					scene.add(rocketObject2);					scene.add(mesh1);					scene.add(mesh2);					scene.add(mesh3);					scene.add(mesh4);					//restarts clock					clock.start();					//console.log(rocketMeshes.length);				}				//performs if object colliding with enemy is bullet				if (name == "bull") {					//decrease this objects life by 1					box1 = box1 + 1;					console.log("hey");				}				if (box1 == 3) {					//If the object has run out of life remove it from the scene					scene.remove(mesh1);					score = score + 2;					scoreText.innerHTML = score.toString();				}			});			mesh2.addEventListener("collision", function(object) {				x = object.id;				name = object.name;				//prevents rocket from moving when collided with				mesh2.setAngularVelocity(new THREE.Vector3(0, 0, 0));				mesh2.setLinearVelocity(new THREE.Vector3(0, 0, 0));				//checks if the collided object is the ufo and scale is a certain size				if (x == ufo.id) {					//resets car as its not big enough to destroy enemy					console.log("nope");					mesh2.setAngularVelocity(new THREE.Vector3(0, 0, 0));					mesh2.setLinearVelocity(new THREE.Vector3(0, 0, 0));					ufo.position.x = 0;					ufo.position.y = 20;					ufo.position.z = 0;					ufo.scale.set(2, 2, 2);					ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));					ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));					ufo.__dirtyPosition = true;					//sets score to 0					score = 0;					scoreText.innerHTML = score.toString();					clock.stop();					alert("You have failed this planet");					scene.add(rocketObject);					scene.add(rocketObject2);					scene.add(mesh1);					scene.add(mesh2);					scene.add(mesh3);					scene.add(mesh4);					clock.start();					//console.log(rocketMeshes.length);				}				//performs if object colliding with enemy is bullet				if (name == "bull") {					box2 = box2 + 1;					console.log("hey");				}				if (box2 == 3) {					scene.remove(mesh2);					score = score + 2;					scoreText.innerHTML = score.toString();				}			});			mesh3.addEventListener("collision", function(object) {				x = object.id;				name = object.name;				//prevents rocket from moving when collided with				mesh3.setAngularVelocity(new THREE.Vector3(0, 0, 0));				mesh3.setLinearVelocity(new THREE.Vector3(0, 0, 0));				//checks if the collided object is the ufo and scale is a certain size				if (x == ufo.id) {					//resets car as its not big enough to destroy enemy					console.log("nope");					mesh3.setAngularVelocity(new THREE.Vector3(0, 0, 0));					mesh3.setLinearVelocity(new THREE.Vector3(0, 0, 0));					ufo.position.x = 0;					ufo.position.y = 20;					ufo.position.z = 0;					ufo.scale.set(2, 2, 2);					ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));					ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));					ufo.__dirtyPosition = true;					//sets score to 0					score = 0;					scoreText.innerHTML = score.toString();					clock.stop();					alert("You have failed this planet");					scene.add(rocketObject);					scene.add(rocketObject2);					scene.add(mesh1);					scene.add(mesh2);					scene.add(mesh3);					scene.add(mesh4);					//restarts clock					clock.start();					//console.log(rocketMeshes.length);				}				//performs if object colliding with enemy is bullet				if (name == "bull") {					box3 = box3 + 1;					console.log("hey");				}				if (box3 == 3) {					scene.remove(mesh3);					score = score + 2;					scoreText.innerHTML = score.toString();				}			});			mesh4.addEventListener("collision", function(object) {				x = object.id;				name = object.name;				//prevents rocket from moving when collided with				mesh4.setAngularVelocity(new THREE.Vector3(0, 0, 0));				mesh4.setLinearVelocity(new THREE.Vector3(0, 0, 0));				//checks if the collided object is the ufo and scale is a certain size				if (x == ufo.id) {					//resets car as its not big enough to destroy enemy					console.log("nope");					mesh4.setAngularVelocity(new THREE.Vector3(0, 0, 0));					mesh4.setLinearVelocity(new THREE.Vector3(0, 0, 0));					ufo.position.x = 0;					ufo.position.y = 20;					ufo.position.z = 0;					ufo.scale.set(2, 2, 2);					ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));					ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));					ufo.__dirtyPosition = true;					//sets score to 0					score = 0;					scoreText.innerHTML = score.toString();					clock.stop();					alert("You have failed this planet");					scene.add(rocketObject);					scene.add(rocketObject2);					scene.add(mesh1);					scene.add(mesh2);					scene.add(mesh3);					scene.add(mesh4);					//restarts clock					clock.start();					//console.log(rocketMeshes.length);				}				//performs if object colliding with enemy is bullet				if (name == "bull") {					box4 = box4 + 1;					console.log("hey");				}				if (box4 == 3) {					scene.remove(mesh4);					score = score + 2;					scoreText.innerHTML = score.toString();				}			});			//adds all our boxes to the scene			scene.add(mesh1);			scene.add(mesh2);			scene.add(mesh3);			scene.add(mesh4);		}		//function to create physics model of rocket		function addRocket() {			//lines 270-288 are always needed when converting model to physics			var rocket = objects[1];			rocket.traverse(function(child) {				if (child.isMesh) {					rocketBuffer = child.geometry;					rocketThings.push(rocketBuffer);				}			});			for (var i = 0; i < rocketThings.length; i++) {				var loader = new THREE.TextureLoader();				var mat = loader.load('textures/gala.jpg');				var carmat = new THREE.MeshBasicMaterial({					map: mat				});				var mesh = new THREE.Mesh(rocketThings[i], carmat);				rocketMeshes.push(mesh);			}			var mats = [carmat];			var rocketbody = new THREE.Geometry().fromBufferGeometry(rocketMeshes[0].geometry);			r.merge(rocketbody, rocketMeshes[0].matrix);			console.log(r);			//creates physics model of rocket			var rocketObj = new Physijs.BoxMesh(r, mats, 0);			//positions rocket in scene			rocketObj.position.x = -100;			rocketObj.position.z = 100;			rocketObj.position.y = 1.6;			rocketObj.rotation.x = -22;			//scales rocket as this model was small , others would need to be scaled by a low factor as they are massive			rocketObj.scale.set(4, 4, 4);			//sets rocket to global variable rocketObject			rocketObject = rocketObj;			//on collision event listener for rocket			rocketObject.addEventListener("collision", function(object) {				x = object.id;				name = object.name;				//prevents rocket from moving when collided with				rocketObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));				rocketObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));				//checks if the collided object is the ufo and scale is a certain size				if (x == ufo.id) {					//resets car as its not big enough to destroy enemy					console.log("nope");					rocketObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));					rocketObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));					ufo.position.x = 0;					ufo.position.y = 20;					ufo.position.z = 0;					ufo.scale.set(2, 2, 2);					ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));					ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));					ufo.__dirtyPosition = true;					//sets score to 0					score = 0;					scoreText.innerHTML = score.toString();					clock.stop();					alert("You have failed this planet");					scene.add(rocketObject);					scene.add(rocketObject2);					scene.add(mesh1);					scene.add(mesh2);					scene.add(mesh3);					scene.add(mesh4);					//restarts clock					clock.start();					console.log(rocketMeshes.length);				}				//performs if object colliding with enemy is bullet				if (name == "bull") {					rocketOneCount = rocketOneCount + 1;					console.log("hey");				}				if (rocketOneCount == 3) {					scene.remove(rocketObject);					score = score + 2;					scoreText.innerHTML = score.toString();				}			});			//push rocket to enemy array			Enemies.push(rocketObject);			scene.add(rocketObject);		}		//does exact thing as function above just with the satellite		function addSatellite() {			//lines 270-288 are always needed when converting model to physics			var rocket = objects[1];			rocket.traverse(function(child) {				if (child.isMesh) {					rocketBuffer = child.geometry;					rocketThings.push(rocketBuffer);				}			});			for (var i = 0; i < rocketThings.length; i++) {				var loader = new THREE.TextureLoader();				var mat = loader.load('textures/neon.jpg');				var carmat = new THREE.MeshBasicMaterial({					map: mat				});				var mesh = new THREE.Mesh(rocketThings[i], carmat);				rocketMeshes.push(mesh);			}			var mats = [carmat];			var rocketbody = new THREE.Geometry().fromBufferGeometry(rocketMeshes[0].geometry);			r.merge(rocketbody, rocketMeshes[0].matrix);			console.log(r);			//creates physics model of rocket			var rocketObj = new Physijs.BoxMesh(r, mats, 0);			//positions rocket in scene			rocketObj.position.x = 200;			rocketObj.position.z = -200;			rocketObj.position.y = 1.6;			rocketObj.rotation.x = -22;			//scales rocket as this model was small , others would need to be scaled by a low factor as they are massive			rocketObj.scale.set(4, 4, 4);			//sets rocket to global variable rocketObject			rocketObject2 = rocketObj;			console.log(rocketObj.id, "heys");			console.log(rocketObj.id);			//on collision event listener for rocket			rocketObject2.addEventListener("collision", function(object) {				x = object.id;				name = object.name;				//prevents rocket from moving when collided with				rocketObject2.setAngularVelocity(new THREE.Vector3(0, 0, 0));				rocketObject2.setLinearVelocity(new THREE.Vector3(0, 0, 0));				//checks if the collided object is the ufo and scale is a certain size				if (x == ufo.id) {					//resets car as its not big enough to destroy enemy					console.log("nope");					rocketObject2.setAngularVelocity(new THREE.Vector3(0, 0, 0));					rocketObject2.setLinearVelocity(new THREE.Vector3(0, 0, 0));					ufo.position.x = 0;					ufo.position.y = 20;					ufo.position.z = 0;					ufo.scale.set(2, 2, 2);					ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));					ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));					ufo.__dirtyPosition = true;					//sets score to 0					score = 0;					scoreText.innerHTML = score.toString();					clock.stop();					alert("You have failed this planet");					scene.add(rocketObject);					scene.add(rocketObject2);					scene.add(mesh1);					scene.add(mesh2);					scene.add(mesh3);					scene.add(mesh4);					//restarts clock					clock.start();					console.log(rocketMeshes.length);				}				//performs if object colliding with enemy is bullet				if (name == "bull") {					rocketTwoCount = rocketTwoCount + 1;					console.log("hey");				}				if (rocketTwoCount == 3) {					scene.remove(rocketObject2);					score = score + 2;					scoreText.innerHTML = score.toString();				}			});			//push rocket to enemy array			Enemies.push(rocketObject2);			scene.add(rocketObject2);		}		//creates Land that we drive on		function createLand() {			var ground_material, ground_geometry, sun, ground;			var loader = new THREE.TextureLoader();			var mat = loader.load('textures/sky.jpg');			ground_material =				new THREE.MeshBasicMaterial({					color: 0xfffff,					opacity: 0,					transparent: true				}); // low restitution,transparent ground			// Ground			ground = new Physijs.BoxMesh(new THREE.BoxGeometry(900, 1, 900), ground_material, 0 // mass			);			scene.add(ground);			//walls			var text = new THREE.TextureLoader();			var mat = text.load("textures/neon.jpg")			var wall_material =				new THREE.MeshLambertMaterial({					color: 0xfe019a				}); // low restitution;			var wallHeight = 30;			var wallLength = 900;			var wall1 = new Physijs.BoxMesh(new THREE.BoxGeometry(wallLength, wallHeight, 15), wall_material, 0 // mass			);			//collision events			wall1.addEventListener('collision', function(object) {				var x = object.id;				if (x == ufo.id) {					alert("You have failed this planet");					//position for ufo)					ufo.position.x = 0;					ufo.position.y = 20;					ufo.position.z = 0;					ufo.scale.set(2, 2, 2);					//sets velocity of ufo to zero so that it doesnt move after the accident					ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));					ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));					move_left = 0;					move_right = 0;					move_up = 0;					move_down = 0;					//always put this when changing position of objects in the scene					ufo.__dirtyPosition = true;					//reset score					score = 0;					scoreText.innerHTML = score.toString();					//stop timer					clock.stop();					scene.add(rocketObject);					scene.add(rocketObject2);					scene.add(mesh1);					scene.add(mesh2);					scene.add(mesh3);					scene.add(mesh4);					//restart timer					clock.start();				}			});			wall1.position.y = wallHeight / 2;			wall1.position.z = wallLength / 2;			scene.add(wall1);			var wall2 = new Physijs.BoxMesh(new THREE.BoxGeometry(wallLength, wallHeight, 15), wall_material, 0 // mass			);			//same as first collision example			wall2.addEventListener('collision', function(object) {				var x = object.id;				if (x == ufo.id) {					alert("You have failed this planet");					ufo.position.x = 0;					ufo.position.y = 20;					ufo.position.z = 0;					ufo.scale.set(2, 2, 2);					ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));					ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));					move_left = 0;					move_right = 0;					move_up = 0;					move_down = 0;					ufo.__dirtyPosition = true;					score = 0;					scoreText.innerHTML = score.toString();					clock.stop();					scene.add(rocketObject);					scene.add(rocketObject2);					scene.add(mesh1);					scene.add(mesh2);					scene.add(mesh3);					scene.add(mesh4);					clock.start();				}			});			wall2.position.y = wallHeight / 2;			wall2.position.z = -wallLength / 2;			scene.add(wall2);			var wall3 = new Physijs.BoxMesh(new THREE.BoxGeometry(15, wallHeight, wallLength), wall_material, 0 // mass			);			//same as first collision example			wall3.addEventListener('collision', function(object) {				var x = object.id;				if (x == ufo.id) {					alert("You have failed this planet");					ufo.position.x = 0;					ufo.position.y = 20;					ufo.position.z = 0;					ufo.scale.set(2, 2, 2);					ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));					ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));					move_left = 0;					move_right = 0;					move_up = 0;					move_down = 0;					ufo.__dirtyPosition = true;					score = 0;					scoreText.innerHTML = score.toString();					clock.stop();					scene.add(rocketObject);					scene.add(rocketObject2);					scene.add(mesh1);					scene.add(mesh2);					scene.add(mesh3);					scene.add(mesh4);					clock.start();				}			});			wall3.position.y = wallHeight / 2;			wall3.position.x = -wallLength / 2;			scene.add(wall3);			var wall4 = new Physijs.BoxMesh(new THREE.BoxGeometry(15, wallHeight, wallLength), wall_material, 0 // mass			);			//same as first collision example			wall4.addEventListener('collision', function(object) {				var x = object.id;				if (x == ufo.id) {					alert("You have failed this planet");					ufo.position.x = 0;					ufo.position.y = 20;					ufo.position.z = 0;					ufo.scale.set(2, 2, 2);					ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));					ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));					move_left = 0;					move_right = 0;					move_up = 0;					move_down = 0;					ufo.__dirtyPosition = true;					score = 0;					scoreText.innerHTML = score.toString();					clock.stop();					scene.add(rocketObject);					scene.add(rocketObject2);					scene.add(mesh1);					scene.add(mesh2);					scene.add(mesh3);					scene.add(mesh4);					clock.start();				}			});			wall4.position.y = wallHeight / 2;			wall4.position.x = wallLength / 2;			scene.add(wall4);		}		//function to create asteroid/planet		function createBall() {			//geometry is a sphere			var ball = new THREE.SphereGeometry(10, 32, 32);			//loads a texture			var loader = new THREE.TextureLoader();			var m = loader.load("textures/moon.jpeg");			//sets material to map to loaded texture , if you want transparency put after 'm' transparent:true,same with opacity but opacity:0.5			var ballmat = new THREE.MeshBasicMaterial({				map: m			});			//physic objects always boxmesh for collision ease			ballObject = new Physijs.SphereMesh(ball, ballmat);			//produces value between 400 and 300			var range = 100 * Math.random() + 300;			//sets ball position based on range			ballObject.position.x = 250;			ballObject.position.z = 50;			ballObject.__dirtyPosition = true;			ballObject.position.y = 10.5;			ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));			ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));			//not sure what this does but just keep it			ballObject.setDamping(0, 0.9);			//ballObjectect.scale.set(5,5,5);//can scale if we want but then we'd have to change y position			scene.add(ballObject);			//ballObject event listener			ballObject.addEventListener('collision', function(object) {				x = object.id;				//check if collided object is the ufo				if (x == ufo.id) {					//find a value from 300-400					var range = 100 * Math.random() + 300;					ballObject.position.y = 10.5;					//checks current ball position					if (ballObject.position.x > 0 && ballObject.position.z > 0) {						//random value from 0-2						val = Math.floor(Math.random() * 3);						//20 lines of code below sets new position of planet depending on random number produced above						if (val == 0) {							ballObject.position.x = -range;							ballObject.position.z = -range;							ballObject.__dirtyPosition = true;							ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));							ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));						} else if (val == 1) {							ballObject.position.x = -range;							ballObject.position.z = range;							ballObject.__dirtyPosition = true;							ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));							ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));						} else if (val == 2) {							ballObject.position.x = range;							ballObject.position.z = -range;							ballObject.__dirtyPosition = true;							ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));							ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));						}					}					//else if for first if					else if (ballObject.position.x > 0 && ballObject.position.z < 0) {						val = Math.floor(Math.random() * 3);						if (val == 0) {							ballObject.position.x = -range;							ballObject.position.z = range;							ballObject.__dirtyPosition = true;							ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));							ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));						} else if (val == 1) {							ballObject.position.x = -range;							ballObject.position.z = -range;							ballObject.__dirtyPosition = true;							ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));							ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));						} else if (val == 2) {							ballObject.position.x = range;							ballObject.position.z = range;							ballObject.__dirtyPosition = true;							ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));							ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));						}					} else if (ballObject.position.x < 0 && ballObject.position.z > 0) {						val = Math.floor(Math.random() * 3);						if (val == 0) {							ballObject.position.x = range;							ballObject.position.z = -range;							ballObject.__dirtyPosition = true;							ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));							ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));						} else if (val == 1) {							ballObject.position.x = -range;							ballObject.position.z = -range;							ballObject.__dirtyPosition = true;							ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));							ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));						} else if (val == 2) {							ballObject.position.x = range;							ballObject.position.z = range;							ballObject.__dirtyPosition = true;							ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));							ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));						}					}					//else if for first if					else if (ballObject.position.x < 0 && ballObject.position.z < 0) {						val = Math.floor(Math.random() * 3);						if (val == 0) {							ballObject.position.x = range;							ballObject.position.z = range;							ballObject.__dirtyPosition = true;							ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));							ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));						} else if (val == 1) {							ballObject.position.x = -range;							ballObject.position.z = range;							ballObject.__dirtyPosition = true;							ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));							ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));						} else if (val == 2) {							ballObject.position.x = range;							ballObject.position.z = -range;							ballObject.__dirtyPosition = true;							ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));							ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));						}					}					//increments score variable if we bump into planet/asteroid					score++;					//converts to string to use in document					scoreText.innerHTML = (score).toString();					//sets ballObject to zero to prevent after collisions					ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));					ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));				}			});			return ballObject;		}		//function to create our UFO		function createUFO() {			//first five lines creates bottom donut part of ufo			var geometry = new THREE.TorusGeometry(10, 2, 16, 100);			var material = new THREE.MeshBasicMaterial({				color: 0xffff00			});			var torus1 = new THREE.Mesh(geometry, material);			torus1.rotation.x = 29.8;			torus1.position.y = -9;			//next five lines creates second bottom donut part of ufo			var geometry = new THREE.TorusGeometry(7, 2, 16, 100);			//var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );			var torus2 = new THREE.Mesh(geometry, material);			torus2.rotation.x = 29.8;			torus2.position.y = -7;			//four lines below create third layer of ufo			var geometry = new THREE.TorusGeometry(5, 2, 16, 100);			var cylinder = new THREE.Mesh(geometry, material);			cylinder.position.y = -5;			cylinder.rotation.x = 29.8;			//five lines below create second top layer			var geometry = new THREE.CylinderGeometry(3.9, 3.9, 2, 64);			var cylinder2 = new THREE.Mesh(geometry, material);			cylinder2.position.y = -3;			cylinder2.rotation.x = 31;			cylinder2.position.x = -0.2;			//creates the ufo ball(indicator)			var geometry = new THREE.SphereGeometry(2, 32, 32);			var sphere = new THREE.Mesh(geometry, material);			sphere.position.y = -2;			var geometry = new THREE.CylinderGeometry(1, 1, 7, 32);			var gun = new THREE.Mesh(geometry, material);			gun.position.y = -1;			//gun.rotation.x=29.3;			//creates our geometry which will contain all our objects from above			var geom = new THREE.Geometry();			//every two lines is the main process for merging objects to one massive object			torus1.updateMatrix();			geom.merge(torus1.geometry, torus1.matrix);			torus2.updateMatrix();			geom.merge(torus2.geometry, torus2.matrix);			cylinder.updateMatrix();			geom.merge(cylinder.geometry, cylinder.matrix);			cylinder2.updateMatrix();			geom.merge(cylinder2.geometry, cylinder2.matrix);			sphere.updateMatrix();			geom.merge(sphere.geometry, sphere.matrix);			gun.updateMatrix();			//  geom.merge(gun.geometry,gun.matrix);			//loading a texture for our ufo			var load = new THREE.TextureLoader();			var mat = load.load('textures/ufob.jpg');			console.log(cubeMat);			var ufoMat = new THREE.MeshLambertMaterial({				map: mat			});			//final ufo			var ufo = new Physijs.BoxMesh(geom, ufoMat);			//y position for ufo			ufo.position.y = 12;			ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));			ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));			//scales ufo uniformly			ufo.scale.set(2, 2, 2);			scene.add(ufo);			var directionalLight2 = new THREE.DirectionalLight(0xffffff, 2);			scene.add(directionalLight2.target); //directionalLight must have a target			directionalLight2.position.set(0, 170, 0);			directionalLight2.target = ufo; //respective target for directionalLight			scene.add(directionalLight2);			return ufo;		}		//function to create big Moon,not in scene anymore as theres a model		function bigMoon() {			var sphere = new THREE.SphereGeometry(50, 32, 32);			var loader = new THREE.TextureLoader();			var mat = loader.load('textures/bigmoon.jpeg');			var material = new THREE.MeshBasicMaterial({				map: mat			});			var mesh = new THREE.Mesh(sphere, material);			mesh.position.y = 190;			mesh.position.x = 250;			mesh.position.x = 450;			//adds bigMoon to group mentioned above			group.add(mesh);			return mesh;		}		//All these variables used in the update function		var ufo;		var score = 0;		var firstTime = 1;		var clock = new THREE.Clock();		var bigmoon;		var ball;		function update() {			//allows to add scene once,if we have functions like createUFO, put it in this if statement so it creates the object once and not every time in the animate loop			if (firstTime) {				createLand();				ufo = createUFO();				addRocket();				boxes();				addSatellite();				//adds camera to ufo				ufo.add(camera);				bigmoon = bigMoon();				ball = createBall();				//this is where we add that group from above				scene.add(group);				//sets firstTime variable to 0 so we can only execute this if statement once for the entire game/level				firstTime = 0;				//event listener for collision with the ufo and planet			}			//rotate group around scene			group.rotation.y += 0.01;			//ill explain this in the meeting , just know this is what creates the map			graphics.fillStyle = "black";			graphics.fillRect(0, 0, 900, 900);			var imgData = graphics.getImageData(0, 0, 900, 900);			var ufoX = parseInt((ufo.position.x + 450) / 3);			var ufoZ = parseInt((ufo.position.z + 450) / 3);			//console.log(imgData.data[0],imgData.data[1],imgData.data[2],imgData.data[3])			if (ufoX < 150) {				ufoX = 150 - ufoX + 150;			} else if (ufoX > 150) {				ufoX = 150 - (ufoX - 150);			}			var t = parseInt((ufoX * 3600 + ufoZ * 4) - 1);			var u = parseInt((ufoX * 3600 + ufoZ * 4) - 3600 - 1);			var v = parseInt((ufoX * 3600 + ufoZ * 4) + 3600 - 1);			var ballX = parseInt((ball.position.x + 450) / 3);			var ballZ = parseInt((ball.position.z + 450) / 3);			if (ballX < 150) {				ballX = 150 - ballX + 150;			} else if (ballX > 150) {				ballX = 150 - (ballX - 150);			}			var x = parseInt((ballX * 3600 + ballZ * 4) - 1);			var y = parseInt((ballX * 3600 + ballZ * 4) - 3600 - 1);			var z = parseInt((ballX * 3600 + ballZ * 4) + 3600 - 1);			imgData.data[t] = 255;			imgData.data[t + 1] = 255;			imgData.data[t + 2] = 0;			imgData.data[t + 3] = 255;			imgData.data[t + 4] = 255;			imgData.data[t + 5] = 255;			imgData.data[t + 6] = 0;			imgData.data[t + 7] = 255;			imgData.data[t - 4] = 255;			imgData.data[t - 3] = 255;			imgData.data[t - 2] = 0;			imgData.data[t - 1] = 255;			imgData.data[u] = 255;			imgData.data[u + 1] = 255			imgData.data[u + 2] = 0;			imgData.data[u + 3] = 255;			imgData.data[u + 4] = 255;			imgData.data[u + 5] = 255;			imgData.data[u + 6] = 0;			imgData.data[u + 7] = 255;			imgData.data[u - 4] = 255;			imgData.data[u - 3] = 255;			imgData.data[u - 2] = 0;			imgData.data[u - 1] = 255;			imgData.data[v] = 255;			imgData.data[v + 1] = 255;			imgData.data[v + 2] = 0;			imgData.data[v + 3] = 255;			imgData.data[v + 4] = 255;			imgData.data[v + 5] = 255;			imgData.data[v + 6] = 0;			imgData.data[v + 7] = 255;			imgData.data[v - 4] = 255;			imgData.data[v - 3] = 255;			imgData.data[v - 2] = 0;			imgData.data[v - 1] = 255;			imgData.data[x] = 255;			imgData.data[x + 1] = 0;			imgData.data[x + 2] = 0;			imgData.data[x + 3] = 255;			imgData.data[x + 4] = 255;			imgData.data[x + 5] = 0;			imgData.data[x + 6] = 0;			imgData.data[x + 7] = 255;			imgData.data[x - 4] = 255;			imgData.data[x - 3] = 0;			imgData.data[x - 2] = 0;			imgData.data[x - 1] = 255;			imgData.data[y] = 255;			imgData.data[y + 1] = 0;			imgData.data[y + 2] = 0;			imgData.data[y + 3] = 255;			imgData.data[y + 4] = 255;			imgData.data[y + 5] = 0;			imgData.data[y + 6] = 0;			imgData.data[y + 7] = 255;			imgData.data[y - 4] = 255;			imgData.data[y - 3] = 0;			imgData.data[y - 2] = 0;			imgData.data[y - 1] = 255;			imgData.data[z] = 255;			imgData.data[z + 1] = 0;			imgData.data[z + 2] = 0;			imgData.data[z + 3] = 255;			imgData.data[z + 4] = 255;			imgData.data[z + 5] = 0;			imgData.data[z + 6] = 0;			imgData.data[z + 7] = 255;			imgData.data[z - 4] = 255;			imgData.data[z - 3] = 0;			imgData.data[z - 2] = 0;			imgData.data[z - 1] = 255;			for (var i = 0; i < Enemies.length; i++) {				var enemyX = parseInt((Enemies[i].position.x + 450) / 3);				var enemyZ = parseInt((Enemies[i].position.z + 450) / 3);				if (enemyX < 150) {					enemyX = 150 - enemyX + 150;				} else if (enemyX > 150) {					enemyX = 150 - (enemyX - 150);				}				var x = parseInt((enemyX * 3600 + enemyZ * 4) - 1);				var y = parseInt((enemyX * 3600 + enemyZ * 4) - 3600 - 1);				var z = parseInt((enemyX * 3600 + enemyZ * 4) + 3600 - 1);				imgData.data[x] = 255;				imgData.data[x + 1] = 0;				imgData.data[x + 2] = 255;				imgData.data[x + 3] = 255;				imgData.data[x + 4] = 255;				imgData.data[x + 5] = 0;				imgData.data[x + 6] = 255;				imgData.data[x + 7] = 255;				imgData.data[x - 4] = 255;				imgData.data[x - 3] = 0;				imgData.data[x - 2] = 255;				imgData.data[x - 1] = 255;				imgData.data[y] = 255;				imgData.data[y + 1] = 0;				imgData.data[y + 2] = 255;				imgData.data[y + 3] = 255;				imgData.data[y + 4] = 255;				imgData.data[y + 5] = 0;				imgData.data[y + 6] = 255;				imgData.data[y + 7] = 255;				imgData.data[y - 4] = 255;				imgData.data[y - 3] = 0;				imgData.data[y - 2] = 255;				imgData.data[y - 1] = 255;				imgData.data[z] = 255;				imgData.data[z + 1] = 0;				imgData.data[z + 2] = 255;				imgData.data[z + 3] = 255;				imgData.data[z + 4] = 255;				imgData.data[z + 5] = 0;				imgData.data[z + 6] = 255;				imgData.data[z + 7] = 255;				imgData.data[z - 4] = 255;				imgData.data[z - 3] = 0;				imgData.data[z - 2] = 255;				imgData.data[z - 1] = 255;			}			graphics.clearRect(0, 0, 900, 900);			canvas.width = 300;			canvas.height = 300;			graphics.putImageData(imgData, 0, 0, 0, 0, 900, 900);			//calls the check function			check();			//checks if we win			//converts time value to string and adds it to document			timer.innerHTML = clock.getElapsedTime().toString();			//Handle the bullets array			handleBullets();			//calls the function that moves the ufo			moveUFO();			//calls change camera orientation function			change_cam_orientation();			//always needed in physics scene			scene.simulate();		}		//animate function loop		function animate() {			update();			renderer.render(scene, camera);			requestAnimationFrame(animate);		}		//varaibles used below for movement and change of camera view		var move_left, move_right, move_up, move_down, pause, jump;		var change_cam_angle;		var y_axis = new THREE.Vector3(0, 1, 0);		//variable used to indicate whether the ufo can shoot yet or not		var can_shoot = 1;		//function to check is timer is at a specific time and score is above certain score		function check() {			//failure of game objective,this is what will happen if we fail			if (clock.getElapsedTime() > 75) {				alert("You've completed the game with a score of:" + score);				clock.stop();				 window.location.href="j(betafinal).html";			}		}		//function to change camera view		function change_cam_orientation() {			if (change_cam_angle) {				camera.position.x = 200;				camera.position.y = 100;				camera.position.z = 200;				camera.lookAt(scene.position);			} else {				camera.position.x = -120;				camera.position.y = 50;				camera.position.z = 0;				camera.rotation.y = -Math.PI / 2;				camera.lookAt(ufo.position);			}		}		//function for moving ufo just use this for movement		function moveUFO() {			if (move_left) {				rot = new THREE.Quaternion().setFromAxisAngle(y_axis, Math.PI / 120);				cur = ufo.quaternion;				cur.multiplyQuaternions(rot, cur);				ufo.__dirtyRotation = true;			} else if (move_right) {				rot = new THREE.Quaternion().setFromAxisAngle(y_axis, -Math.PI / 120);				cur = ufo.quaternion;				cur.multiplyQuaternions(rot, cur);				ufo.__dirtyRotation = true;			} else if (move_up) {				var curr_rotation = new THREE.Matrix4().extractRotation(ufo.matrix);				//console.log(curr_rotation);				var force_vector = new THREE.Vector3(60000, 0, 0).applyMatrix4(curr_rotation);				//console.log(force_vector);				ufo.applyCentralImpulse(force_vector);				ufo.__dirtyPosition = true;			} else if (move_down) {				var curr_rotation = new THREE.Matrix4().extractRotation(ufo.matrix);				var force_vector = new THREE.Vector3(-60000, 0, 0).applyMatrix4(curr_rotation);				ufo.applyCentralImpulse(force_vector);				ufo.__dirtyPosition = true;			} else if (pause) {				ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));				ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));			} else if (jump) {				ufo.position.y = 90;				ufo.__dirtyPosition = true;			}		}		//if you press left,right,up,down,spaceBar,ESC,Enter , sets respective variable to 1 for the moveUFO function		document.addEventListener('keydown', function(event) {			var code = event.keyCode;			//move_left=0;move_right=0;move_up=0;move_down=0;pause=0;			if (code == 37) {				move_left = 1;			}			if (code == 38) {				move_up = 1;			}			if (code == 39) {				move_right = 1;			}			if (code == 40) {				move_down = 1;			}			if (code == 32) {				pause = 1;			}			if (code == 27) {				change_cam_angle = 1;			}			if (code == 13) {				jump = 1;			}			if (code == 16) {				//this is just here as sometimes the scene takes long to load , thank you WiFi , so just press shift to reset clock and score to 0. If you start the game and see the timer is high just press Shift before starting				clock.start();				score = 0;				scoreText.innerHTML = score.toString();			}		});		//when you release left,right,up,down,spaceBar,ESC,Enter , sets respective variable to 0 for the moveUFO function		document.addEventListener('keyup', function(event) {			var code = event.keyCode;			//move_left=1;move_right=1;move_up=1;move_down=1;pause=0;			if (code == 37) {				move_left = 0;			}			if (code == 38) {				move_up = 0;			}			if (code == 39) {				move_right = 0;			}			if (code == 40) {				move_down = 0;			}			if (code == 32) {				pause = 0;			}			if (code == 27) {				change_cam_angle = 0;			}			if (code == 13) {				jump = 0;			}		});		//Handle bullets		function handleBullets() {			//Loop through all the bullets and remove them if they are no longer alive			var num_bullets = bullets.length;			for (var i = 0; i < num_bullets; i++) {				if (bullets[i] == undefined) {					continue;				}				if (bullets[i].alive == false) {					bullets.splice(i, 1);					i--;					continue;				}			}		}		//event listener for when clicking on screen to shoot a bullet in the direction		//the ufo is currently facing		document.addEventListener('click', function(event) {			//first checks whether the ufo is allowed to shoot yet			if (can_shoot) {				//create the bullet object				var bullet = new Physijs.SphereMesh(new THREE.SphereGeometry(1.3, 8.8), new THREE.MeshBasicMaterial({					color: 0xffffff				}));				//set bullet to be alive and create a timer for how long it should be alive for				//and then remove the bullet from the scene				bullet.alive = true;				setTimeout(function() {					bullet.alive = false;					scene.remove(bullet);				}, 6000);				//Get current rotation of ufo				var curr_rotation = new THREE.Matrix4().extractRotation(ufo.matrix);				//Get the force vector to make the bullet move in the correct direction				var force_vector = new THREE.Vector3(2000, 0, 0).applyMatrix4(curr_rotation);				//Get the direction vector the ufo is facing in to position the ball when it is shot				var dir_vector = new THREE.Vector3(30, 0, 0).applyMatrix4(curr_rotation);				//Set the initial position of the ball just in front of the ufo				bullet.position.x = ufo.position.x + dir_vector.x;				bullet.position.z = ufo.position.z + dir_vector.z;				bullet.position.y = 5;				//Set the name of the object to be used in identifying the object in collisions				bullet.name = "bull";				//Set can_shoot = false and create a timer for the ufo can shoot again				can_shoot = 0;				setTimeout(function() {					can_shoot = 1;				}, 500);				//Add the bullet object to the bullets array				bullets.push(bullet);				//Add the bullet to the scene				scene.add(bullet);				//Apply a force to the bullet that was just created in order to make it move				bullets[bullets.length-1].applyCentralImpulse(force_vector);				bullets[bullets.length-1].__dirtyPosition = true;			}		});	</script></body></html>